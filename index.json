[{"uri":"https://RHTE-2023-Edge-Lab.github.io/use-case/","title":"Use Case","tags":[],"description":"","content":"Chapter 1 Use case You and your team are part of the FSC (Fedora Shipping Company), a company that provides shipping and delivery services in EMEA.\nCurrently, the company has one Headquarter and ten Warehouses spread across Europe.\nYou and your team (watch around you, there are people around your table!) have been hired to setup the required IT infrastructure to track parcels along their journey.\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/use-case/goal/","title":"Goal","tags":[],"description":"","content":"Your goal will be to deploy everything needed to: read the parcel RFID (using arduino and ESP32), send data to a MQTT broker over wifi, transform those data using Camel-K and send relevant events over Kafka to the headquarter for reporting.\nThe headquarter is already setup and is waiting for your data!\nOnce your setup is complete, you should be able to scan your parcels (look around you, there should be four parcels on your table!) and see them move over the global map.\n  "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/pre-requisites/general/","title":"General","tags":[],"description":"","content":"OpenShift Cluster OpenShift cluster is already deployed via RHPDS environment and \u0026ldquo;OpenSHift 4.11 Workshop\u0026rdquo; service. The headquarter and warehouses corresponding to different namespace on this Openshift cluster on this way :\n Namespace n°1 : headquarter Namespace n°2 : warehouse-athens Namespace n°3 : warehouse-brno Namespace n°4 : warehouse-brussels Namespace n°5 : warehouse-bucharest Namespace n°6 : warehouse-dublin Namespace n°7 : warehouse-lisboa Namespace n°8 : warehouse-london Namespace n°9 : warehouse-paris Namespace n°10 : warehouse-stockolm Namespace n°11 : warehouse-varsovia  OpenShift Operators All needed operators are already installed on the Openshift cluster and you will just need to consume CRD provided by these operators during this session :\n  Red Hat Integration - AMQ Broker for RHEL 8 (Multiarch)\nAMQ Broker Operator for RHEL 8 (Multiarch) provides the ability to deploy and manage stateful AMQ Broker broker clusters\n  Red Hat Integration - AMQ Streams\nRed Hat AMQ Streams is a massively scalable, distributed, and high performance data streaming platform based on the Apache Kafka® project. AMQ Streams provides an event streaming backbone that allows microservices and other application components to exchange data with extremely high throughput and low latency. The core capabilities include: * A pub/sub messaging model, similar to a traditional enterprise messaging system, in which application components publish and consume events to/from an ordered stream\n   The long term, fault-tolerant storage of events The ability for a consumer to replay streams of events The ability to partition topics for horizontal scalability   Red Hat Integration - Camel K\nRed Hat Integration - Camel K is a lightweight integration platform, born on Kubernetes, with serverless superpowers.  "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/use-case/organization/","title":"Organization","tags":[],"description":"","content":"During this lab, you will work in pair programming (that is to say: three duo).\n Duo A is in charge of implementing the code on ESP8266 to scan the incoming parcels using RFID and send the data over MQTT. Duo B is in charge of implementing the code on ESP8266 to scan the outgoing parcels using RFID and send the data over MQTT. Duo C is in charge of setting up Kafka Broker, MirrorMaker2 and implementing the Camel-K integration. Duo A or B (whoever finishes first) is in charge of deploying the MQTT broker.  Steps 1. Scan entrance and output packets via the ESP8266 RFID scanner. One ESP8266 dedicated for entrance packets and one ESP8266 dedicated for output packets.\n2. The ESP8266 dedicated for entrance packets write the RFID id in mqtt the mqtt-in. The ESP8266 dedicated for output packets write the RFID id in the mqtt mqtt-out.\n3. Camel K operator transform and enrich mqtt data stored in mqtt topics and inject these enriched data in kafka-in and kafka-out topics.\n4. Kafka Mirror Maker mirror in synchrone mode each topic of each warehouse (10) to headquarter to centralize data.\n5. Camel Quarkus help us to have more complex data transformation to aggregate data stored in all regional kafka topics in one and uniq kafka topic (aggregration).\n6. Kafka Stream relies on a rocksdb database to correlate packet inputs/outputs and finally stores this information in the kafka topic shipment.\n7. A web front based on Quarkus and connected to the kafka topic shipment display data and packages transit on a world map where are represented all warehouses.\nSchema "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/pre-requisites/","title":"Pre Requisites","tags":[],"description":"","content":"Chapter 2 Pre-requisites Pick the section that matches your Operating System and install the pre-requisites.\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/pre-requisites/linux/","title":"Linux","tags":[],"description":"","content":"OpenShift CLI Install the OpenShift CLI.\ncurl -sSfL https://mirror.openshift.com/pub/openshift-v4/clients/ocp/4.11.21/openshift-client-linux.tar.gz | tar -zx -C /usr/local/bin oc kubectl Install git.\nsudo dnf install git Install VScode.\nsudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c \u0026#39;echo -e \u0026#34;[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\u0026#34; \u0026gt; /etc/yum.repos.d/vscode.repo\u0026#39; dnf check-update sudo dnf install code Open VScode and install the PlatformIO IDE plugin.\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/use-case/ice-breaker/","title":"Ice Breaker","tags":[],"description":"","content":"TODO\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/pre-requisites/macos/","title":"MacOS","tags":[],"description":"","content":"Install the OpenShift CLI.\ncurl -sSfL https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-mac.tar.gz | tar -zx -C /usr/local/bin oc kubectl Install git.\nbrew install git Install mosquitto (for MQTT tests).\nbrew install mosquitto Install VScode.\nhttps://code.visualstudio.com/download Open VScode and install the PlatformIO IDE plugin.\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/mqtt-broker/","title":"MQTT Broker","tags":[],"description":"","content":"MQTT Broker in each warehouse Duo A \u0026amp; B - Deploy your MQTT Broker in your dedicated namespace corresponding to your warehouse apiVersion: broker.amq.io/v1beta1 kind: ActiveMQArtemis metadata: name: mqtt namespace: \u0026lt;your_namespace\u0026gt; spec: acceptors: - connectionsAllowed: 5 expose: true name: mqtt port: 1883 protocols: mqtt sslEnabled: false adminPassword: public adminUser: admin console: expose: true deploymentPlan: image: placeholder jolokiaAgentEnabled: false journalType: nio managementRBACEnabled: true messageMigration: false persistenceEnabled: false requireLogin: true size: 1 Duo A \u0026amp; B - Deploy your Service in LoadBalancer type apiVersion: v1 kind: Service metadata: name: mqtt-lb namespace: \u0026lt;your_namespace\u0026gt; spec: ports: - name: mqtt-lb port: 1883 protocol: TCP targetPort: 1883 selector: ActiveMQArtemis: mqtt application: mqtt-app type: LoadBalancer Duo A - Deploy your AMQ Broker Address for your MQTT topic IN for entrance packets kind: ActiveMQArtemisAddress apiVersion: broker.amq.io/v1beta1 metadata: name: esp8266-in namespace: \u0026lt;your_namespace\u0026gt; spec: addressName: esp8266-in queueName: myQueue0 routingType: anycast Duo B - Deploy your AMQ Broker Address for your MQTT topic OUT for output packets kind: ActiveMQArtemisAddress apiVersion: broker.amq.io/v1beta1 metadata: name: esp8266-out namespace: \u0026lt;your_namespace\u0026gt; spec: addressName: esp8266-out queueName: myQueue0 routingType: anycast Result MQTT Instances MQTT Pods MQTT Services Test your MQTT deployment  Connect to your MQTT Broker to read messages  mosquitto_sub -t \u0026lt;MQTT addressName\u0026gt; -h \u0026#39;\u0026lt;AWS LB address for MQTT service\u0026gt;\u0026#39; -p \u0026lt;port\u0026gt; -u \u0026lt;MQTT user\u0026gt; -P \u0026lt;MQTT password\u0026gt; #Example #mosquitto_sub -t esp8266-in -h \u0026#39;a32ba3beef5cf47ba907ca93f911bd94-62424187.eu-west-1.elb.amazonaws.com\u0026#39; -p 1883 -u admin -P public Push new messages to your MQTT Broker  for i in {1..200}; do mosquitto_pub -t \u0026lt;MQTT addressName\u0026gt; -h \u0026#39;\u0026lt;AWS LB address for MQTT service\u0026gt;\u0026#39; -p \u0026lt;port\u0026gt; -u \u0026lt;MQTT user\u0026gt; -P \u0026lt;MQTT password\u0026gt; -m in$i; done #Example #for i in {1..200}; do mosquitto_pub -t esp8266-in -h \u0026#39;aa47f83e624da4e639f5be6109757355-1944403232.eu-west-1.elb.amazonaws.com\u0026#39; -p 1883 -u admin -P public -m in$i; done "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/esp8266/","title":"Program the ESP8266","tags":[],"description":"","content":"Program the ESP8266 1. Duo A \u0026amp; B - Connect your ESP8266 Connect ESP8266 to your computer via USB connector.\n2. Duo A \u0026amp; B - Create new project in PlaformIO VSCode plugin 3. Duo A \u0026amp; B - Add specific libraries in your new create project   Library MFRC522 by Miguel André Balboa : Arduino RFID Library for MFRC522 (SPI). Read/Write a RFID Card or Tag using the ISO/IEC 14443A/MIFARE interface.\n  Library PubSubClient by Nick O\u0026rsquo;Leary : A client library for MQTT messaging. MQTT is a lightweight messaging protocol ideal for small devices. This library allows you to send and receive MQTT messages. It supports the latest MQTT 3.1.1 protocol and can be configured to use the older MQTT 3.1 if needed. It supports all Arduino Ethernet Client compatible hardware, including the Intel Galileo/Edison, ESP8266 and TI CC3000.\n  4. Duo A - Deploy, build and upload code on your ESP8266 dedicated for entrence packets Adapt this code in the src/main.cpp file of your plarformIO project #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;SPI.h\u0026gt; #include \u0026lt;MFRC522.h\u0026gt; #include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;PubSubClient.h\u0026gt; MFRC522 mfrc522; WiFiClient espClient; PubSubClient client(espClient); //WIFI const char* ssid = \u0026#34;\u0026lt;wifi_ssid\u0026gt;\u0026#34;; // SSID Wifi const char* password = \u0026#34;\u0026lt;wifi_password\u0026gt;\u0026#34;; //mot de passe Wifi // MQTT Broker const char *mqtt_broker = \u0026#34;\u0026lt;AWS LB address for MQTT service\u0026gt;\u0026#34;; const char *mqtt_topic = \u0026#34;esp8266-int\u0026#34;; const char *mqtt_username = \u0026#34;\u0026lt;MQTT user\u0026gt;\u0026#34;; const char *mqtt_password = \u0026#34;\u0026lt;MQTT password\u0026gt;\u0026#34;; const int mqtt_port = \u0026lt;MQTT port\u0026gt;; void setup() { Serial.begin(9600); // Initialize serial communications with the PC while (!Serial); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4) Serial.println(\u0026#34;Initializing...\u0026#34;); SPI.begin(); // Init SPI bus mfrc522.PCD_Init(); // Init MFRC522 delay(4); // Optional delay. if (!mfrc522.PCD_PerformSelfTest()) { Serial.println(\u0026#34;MFRC522 not ready !\u0026#34;); } Serial.println(\u0026#34;Ready !\u0026#34;); // Wifi initialization WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); Serial.print(\u0026#34;Connecting to Wifi...\u0026#34;); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\u0026#34;.\u0026#34;); } Serial.println(); Serial.print(\u0026#34;Connected, IP address: \u0026#34;); Serial.println(WiFi.localIP()); randomSeed(micros()); // MQTT initialization client.setServer(mqtt_broker, mqtt_port); } void reconnect() { // Loop until we\u0026#39;re reconnected while (!client.connected()) { Serial.print(\u0026#34;Attempting MQTT connection...\u0026#34;); // Create a random client ID String clientId = \u0026#34;ESP8266Client-\u0026#34;; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str(), mqtt_username, mqtt_password)) { Serial.println(\u0026#34;connected to MQTT Broker\u0026#34;); } else { Serial.print(\u0026#34;failed, rc=\u0026#34;); Serial.print(client.state()); Serial.println(\u0026#34; try again in 5 seconds\u0026#34;); // Wait 5 seconds before retrying delay(5000); } } } void loop() { // MQTT connection to the broker + protocol handling if (!client.connected()) { reconnect(); } client.loop(); // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle. if ( ! mfrc522.PICC_IsNewCardPresent()) { return; } // Select one of the cards if ( ! mfrc522.PICC_ReadCardSerial()) { return; } // Compute and print UID char uid[30]; char * buffer = uid; for (byte i = 0; i \u0026lt; mfrc522.uid.size; i++) { int n = sprintf(buffer, \u0026#34;%s%02x\u0026#34;, i \u0026gt; 0 ? \u0026#34;:\u0026#34; : \u0026#34;\u0026#34;, mfrc522.uid.uidByte[i]); if (n \u0026gt; 0) { buffer += n; } } Serial.println(uid); client.publish(mqtt_topic, uid); delay(500); } Compile your code Flash your ESP8266 with your code Connect to your ESP8266 console Result 4. Duo B - Deploy, build and upload code on your ESP8266 dedicated for output packets Adapt this code in the src/main.cpp file of your plarformIO project #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;SPI.h\u0026gt; #include \u0026lt;MFRC522.h\u0026gt; #include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;PubSubClient.h\u0026gt; MFRC522 mfrc522; WiFiClient espClient; PubSubClient client(espClient); //WIFI const char* ssid = \u0026#34;\u0026lt;wifi_ssid\u0026gt;\u0026#34;; // SSID Wifi const char* password = \u0026#34;\u0026lt;wifi_password\u0026gt;\u0026#34;; //mot de passe Wifi // MQTT Broker const char *mqtt_broker = \u0026#34;\u0026lt;AWS LB address for MQTT service\u0026gt;\u0026#34;; const char *mqtt_topic = \u0026#34;esp8266-out\u0026#34;; const char *mqtt_username = \u0026#34;\u0026lt;MQTT user\u0026gt;\u0026#34;; const char *mqtt_password = \u0026#34;\u0026lt;MQTT password\u0026gt;\u0026#34;; const int mqtt_port = \u0026lt;MQTT port\u0026gt;; void setup() { Serial.begin(9600); // Initialize serial communications with the PC while (!Serial); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4) Serial.println(\u0026#34;Initializing...\u0026#34;); SPI.begin(); // Init SPI bus mfrc522.PCD_Init(); // Init MFRC522 delay(4); // Optional delay. if (!mfrc522.PCD_PerformSelfTest()) { Serial.println(\u0026#34;MFRC522 not ready !\u0026#34;); } Serial.println(\u0026#34;Ready !\u0026#34;); // Wifi initialization WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); Serial.print(\u0026#34;Connecting to Wifi...\u0026#34;); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\u0026#34;.\u0026#34;); } Serial.println(); Serial.print(\u0026#34;Connected, IP address: \u0026#34;); Serial.println(WiFi.localIP()); randomSeed(micros()); // MQTT initialization client.setServer(mqtt_broker, mqtt_port); } void reconnect() { // Loop until we\u0026#39;re reconnected while (!client.connected()) { Serial.print(\u0026#34;Attempting MQTT connection...\u0026#34;); // Create a random client ID String clientId = \u0026#34;ESP8266Client-\u0026#34;; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str(), mqtt_username, mqtt_password)) { Serial.println(\u0026#34;connected to MQTT Broker\u0026#34;); } else { Serial.print(\u0026#34;failed, rc=\u0026#34;); Serial.print(client.state()); Serial.println(\u0026#34; try again in 5 seconds\u0026#34;); // Wait 5 seconds before retrying delay(5000); } } } void loop() { // MQTT connection to the broker + protocol handling if (!client.connected()) { reconnect(); } client.loop(); // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle. if ( ! mfrc522.PICC_IsNewCardPresent()) { return; } // Select one of the cards if ( ! mfrc522.PICC_ReadCardSerial()) { return; } // Compute and print UID char uid[30]; char * buffer = uid; for (byte i = 0; i \u0026lt; mfrc522.uid.size; i++) { int n = sprintf(buffer, \u0026#34;%s%02x\u0026#34;, i \u0026gt; 0 ? \u0026#34;:\u0026#34; : \u0026#34;\u0026#34;, mfrc522.uid.uidByte[i]); if (n \u0026gt; 0) { buffer += n; } } Serial.println(uid); client.publish(mqtt_topic, uid); delay(500); } Compile your code Flash your ESP8266 with your code Connect to your ESP8266 console Result "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/pre-requisites/windows/","title":"Windows","tags":[],"description":"","content":"TODO\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/kafka-broker/","title":"Kafka Broker","tags":[],"description":"","content":"Install the kafka broker Duo C - Create your Kafka broker in your warehouse namespace apiVersion: kafka.strimzi.io/v1beta2 kind: Kafka metadata: name: warehouse namespace: \u0026lt;your_namespace\u0026gt; spec: kafka: config: offsets.topic.replication.factor: 3 transaction.state.log.replication.factor: 3 transaction.state.log.min.isr: 2 default.replication.factor: 3 min.insync.replicas: 2 inter.broker.protocol.version: \u0026#39;3.2\u0026#39; storage: type: ephemeral listeners: - authentication: type: scram-sha-512 name: plain port: 9092 type: internal tls: false - authentication: type: scram-sha-512 name: tls port: 9093 type: route tls: true version: 3.2.3 replicas: 3 entityOperator: topicOperator: {} userOperator: {} zookeeper: storage: type: ephemeral replicas: 3 Duo C - Create your Kafka IN and OUT topics in your broker kind: KafkaTopic apiVersion: kafka.strimzi.io/v1beta2 metadata: name: warehouse-in namespace: \u0026lt;your_namespace\u0026gt; labels: strimzi.io/cluster: warehouse spec: config: retention.ms: 604800000 segment.bytes: 1073741824 --- kind: KafkaTopic apiVersion: kafka.strimzi.io/v1beta2 metadata: name: warehouse-out namespace: \u0026lt;your_namespace\u0026gt; labels: strimzi.io/cluster: warehouse spec: config: retention.ms: 604800000 segment.bytes: 1073741824 Result Kafka pods\nKafka instances\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/camel-k/","title":"Camel-K Integration","tags":[],"description":"","content":"Deploy Camel K integration Duo C - Create a Kafka user for Camel K integration Create the secret containing camel user passord\nkind: Secret apiVersion: v1 metadata: name: camel-user namespace: \u0026lt;your_namespace\u0026gt; stringData: password: s3cr3t type: Opaque Create the Kafka user for Camel K\n--- apiVersion: kafka.strimzi.io/v1beta2 kind: KafkaUser metadata: name: camel namespace: \u0026lt;your_namespace\u0026gt; labels: strimzi.io/cluster: warehouse spec: authentication: password: valueFrom: secretKeyRef: name: camel-user key: password type: scram-sha-512 "},{"uri":"https://RHTE-2023-Edge-Lab.github.io/mirromaker2/","title":"MirrorMaker2","tags":[],"description":"","content":"Duo C Configure MirrorMaker2 TODO\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/testing/","title":"Testing","tags":[],"description":"","content":"Duo A, B \u0026amp; C Test your setup! TODO\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/","title":"Welcome","tags":[],"description":"","content":"RHTE 2023 Edge Lab Welcome, dear Red Hatter, in this Lab where you will discover a part of the Red Hat Edge offering.\nYou will play with the following technologies:\n ESP8266 MQTT AMQ Broker AMQ Streams (Apache Kafka Broker \u0026amp; MirrorMaker2) OpenShift Camel-K  And if you plan to have a look under the hood, you will learn about:\n Quarkus ArgoCD Camel Kafka Streams  In this lab, you will be at the head of a shipping and delivery company, with multiple warehouses and you will deploy everything needed to: read the parcel RFID (using arduino and ESP32), send data to a MQTT broker over wifi, transform those data using Camel-K and send relevant events to the headquarter for reporting.\nAn application at the headquarter will display the parcels moving from one hub to another in realtime.\nTeam work and fun are expected ahead!\n"},{"uri":"https://RHTE-2023-Edge-Lab.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://RHTE-2023-Edge-Lab.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]